# ruHumanEval

## Описание задачи

**Russian HumanEval (ruHumanEval)** является русским аналогом оригинального датасета [HumanEval](https://huggingface.co/datasets/openai_humaneval) [1], созданного для оценки возможностей языковых моделей генерировать код на языке программирования Python для решения простых задач. Датасет направлен на измерение функциональной корректности генерации кода на основе информации из строк документации функции — текстового описания работы функции и нескольких примеров результатов для разных входных данных.

**Важно!** В целях избежания утечки данных, для HumanEval мы создали **НОВУЮ закрытую тестовую часть датасета**, которая по своей структуре и методологии полностью повторяет оригинальный тест, но содержит новые примеры. В связи с этим **результаты моделей на HumanEval и ruHumanEval нельзя напрямую сравнивать между собой.**


**Замечание:** Это диагностическое задание с открытым тестом. Результат на ней не участвует в расчет общего результата (Total score) модели на бенчмарке. 
Результаты моделей на HumanEval и ruHumanEval нельзя напрямую сравнивать между собой. Помимо это, так как открытые данные это публичный тест из оригинального HumanEval, не используйте их для обучения!



**Ключевые слова:** PLP, программирование, Python.

### Мотивация

Данная задача проверяет способность моделей генерировать простые программы на языке Python по описанию (условию) на естественном языке. Так как большие модели имеют в обучающем корпусе долю текстов (программ) написанных на различных языках программирования, предполагается, что они обладают способностью понимать и составлять код для простых задач.

## Описание датасета

### Поля Данных

- instruction — строка, содержащая формулировку запроса к языковой модели;
- inputs — словарь, содержащий входные данные задания:
    - function — строка, содержащая сигнатуру функции, а также ее док-строку в виде недописанной функции;
    - tests — строка со списком словарей, которая содержит входные данные тестовых кейсов для данной задачи (вариантов входных данных, на которых тестируется итоговый код функции);
- outputs — двумерный массив строк размера (n_samples, n_tests), где n_samples - количество сэмплов, требуемое для подсчета метрики pass@k, n_tests - количество тестовых кейсов в tests; каждый список в outputs одинаков и содержит корректные ответы в виде строк на все тестовые кейсы.
- meta — cловарь, содержащий метаинформацию:
    - id — номер примера;
    - canonical_solution — каноническое решение задачи [только в трейн сете];
    - entry_point — имя функции.

### Пример данных

Ниже приведен пример данных:

```json
{
	"instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
	"inputs": {
		"function": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"Входными данными для этой функции является строка, представленная несколькими группами вложенных круглых скобок, разделенных пробелами. Для каждой группы выведите самый глубокий уровень вложенности круглых скобок. Например, (()()) имеет максимум два уровня вложенности, в то время как ((())) имеет три.\n    Примеры: \n        parse_nested_parens('(()()) ((())) () ((())()())') \n        [2, 3, 1, 3]\n    \"\"\"",
		"tests": "[{'paren_string': ''}, {'paren_string': '((()))'}, {'paren_string': '(())(()())'}, {'paren_string': '(())(()(()))((()()))'}, {'paren_string': '(()()(((())))(()(())))()'}, {'paren_string': '()((()))'}, {'paren_string': '(())'}, {'paren_string': '()()()'}, {'paren_string': '()(())'}, {'paren_string': '((())()) ()(()()) ((())) ((())())'}]"
	},
	"outputs": [
		"[]",
		"[3]",
		"[2]",
		"[3]",
		"[5]",
		"[3]",
		"[2]",
		"[1]",
		"[2]",
		"[3, 2, 3, 3]"
	],
	"meta": {
		"id": 6,
		"canonical_solution": "\n    \n    def count_depth(s: str) -> int:\n        max_depth, cnt = 0, 0\n        for ch in s:\n            if ch == \"(\": cnt += 1\n            if ch == \")\": cnt -= 1\n            max_depth = max(max_depth, cnt)\n        return max_depth\n    \n    return [count_depth(s) for s in paren_string.split(\" \") if s != \"\"]\n\n",
		"entry_point": "parse_nested_parens"
	}
}
```

### Разбиение данных

Публичный тестсет содержит 164 примера с тестовыми кейсами и ответами. 

### Промпты

Для датасета было подготовлено 10 промптов разной сложности.

Пример промпта:

```json
"Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}"
```

### Создание Датасета

Открытый сет — это публичный открытый тестовый датасет [openai_humaneval](https://huggingface.co/datasets/openai_humaneval) с переведенными на русский язык описаниями условий. В сете исправлены некоторые опечатки в условиях и решениях, а также учтены исправления, описанные в [2].

Тестовый закртый сет был собран из открытых источников вручную по формату оригинального открытого сета и также скорректирован во избежание утечки данных в обучении.

## Оценка

### Метрики

Оценка решения проводится с помощью метрики pass@k, вычисляемой по формуле:

![https://mera.a-ai.ru/storage/editor/sbCvfIHvx7bb4OYHurmj2S53VgKL90aXb7eyKtxx.png](https://mera.a-ai.ru/storage/editor/sbCvfIHvx7bb4OYHurmj2S53VgKL90aXb7eyKtxx.png)

Select an Image

Обозначения: n - общее количество сгенерированных вариантов решений, c - число решений, которые являются корректными, k - выбираемый показатель, сколько вариантов учитываем.

Чтобы оценить pass@k, генерируется n ≥ k вариантов решения для каждой задачи, через которые прогоняются тестовые кейсы (используем n = 10 и k ≤ 10 и в среднем 10 тест-кейсов на задачу), считается количество правильных решений при условии, что всегда c ≤ n. Правильность решения определяется по результатам прохождения модульных тестов, то есть результат прогонов решений  на тест-кейсах должен совпасть с правильными ответами на тест-кейсы одной задачи. Полученная в результате оценка является несмещеной.

### Человеческая оценка

Датасет включает в себя алгоритмические задачи, для решения которых требуется знание языка программирования Python, что является слишком сложной задачей для среднего разметчика. Все задачи имеют строгие решения, потому все метрики человеческой оценки принимаются за 1.0.

## Ссылки

[1] Chen, Mark, et al. "Evaluating large language models trained on code." *arXiv preprint arXiv:2107.03374* (2021).

[2] Jiawei Liu, Chunqiu Steven Xia, Yuyao Wang, Lingming Zhang Is Your Code Generated by ChatGPT Really Correct? Rigorous Evaluation of Large Language Models for Code Generation
